var jsCall = function(obj, f){ return obj[f].apply(obj, Array.prototype.slice.call(arguments, 2)); };var newObject = function(){ return {}; };var objGet = function(obj, key){ return obj[key]; };var jsGet = objGet;var objSetExcl = function(obj, key, value){ return (function(){obj[key] = value;return obj;})(); };var hasKey = function(obj, key){ return (obj[key]&&jsCall(obj, "hasOwnProperty", key)); };var cons = function(a1, a2){ return jsCall([a1], "concat", a2); };var conc = function(a1, a2){ return jsCall(a1, "concat", a2); };var len = function(coll){ return jsGet(coll, "length"); };var indexOf = function(coll, i){ return jsCall(coll, "indexOf", i); };var replace = function(s, mat, val){ return jsCall(s, "replace", mat, val); };var head = function(l){ return l[0]; };var objStr = function(obj){ return Object.prototype.toString.call(obj); };var matches = function(stri, regex){ return jsCall(stri, "match", regex); };var slice = function(l, start, end){ return jsCall(l, "slice", start, end); };var split = function(s, splitter){ return jsCall(s, "split", splitter); };var join = function(coll, s){ return jsCall(coll, "join", s); };var foreach = function(coll, f){ return jsCall(coll, "forEach", f); };var map = function(coll, f){ return jsCall(coll, "map", f); };var reduce = function(coll, f){ return jsCall(coll, "reduce", f); };var reduceR = function(coll, f){ return jsCall(coll, "reduceRight", f); };var fold = function(coll, f, init){ return jsCall(coll, "reduce", f, init); };var foldR = function(coll, f, init){ return jsCall(coll, "reduceRight", f, init); };var upper = function(s){ return jsCall(s, "toUpperCase"); };var lower = function(s){ return jsCall(s, "toLowerCase"); };var toArray = function(coll){ return Array.prototype.slice.call(coll); };var app = function(f, args){ return jsCall(f, "apply", null, args); };var log = function(msg){ return (function(){jsCall(console, "log", msg);return msg;})(); };var err = function(msg){ return (function(){jsCall(console, "error", msg);return msg;})(); };var argv = jsGet(process, "argv");var newVar = function(initial){ return (function(){var AstskvarAstsk = newObject();objSetExcl(AstskvarAstsk, "value", initial);return AstskvarAstsk;})(); };var varSetExcl = function(AstskvarAstsk, value){ return objSetExcl(AstskvarAstsk, "value", value); };var varGet = function(AstskvarAstsk){ return objGet(AstskvarAstsk, "value"); };var varSwapExcl = function(AstskvarAstsk, f){ return (function(){var curVal = varGet(AstskvarAstsk);var newVal = f(curVal);return varSetExcl(AstskvarAstsk, newVal);})(); };var list = function(){ return toArray(arguments); };var empty = function(l){ return (len(l)===0); };var init = function(l){ return slice(l, 0, (len(l)-1)); };var last = function(l){ return at(l, (len(l)-1)); };var push = function(l, elem){ return conc(l, list(elem)); };var has = function(l, item){ return (empty(l) ? false : ((head(l)===item) ? true : has(tail(l), item))); };var at = function(l, i){ return (empty(l) ? err("cannot at from empty list") : ((i===0) ? head(l) : at(tail(l), (i-1)))); };var from = function(l, start){ return slice(l, start, len(l)); };var tail = function(l){ return from(l, 1); };var irange = function(end){ return ((end===0) ? list(0) : push(irange((end-1)), end)); };var range = function(end){ return init(irange(end)); };var zip = function(coll1, coll2){ return ((len(coll1)===len(coll2)) ? map(range(len(coll1)), function(i){ return list(at(coll1, i), at(coll2, i)); }) : err("collections must be same size")); };var take = function(i, coll){ return ((i===0) ? [] : push(take((i-1), coll), at(coll, i))); };var group2 = function(coll){ return (empty(coll) ? [] : cons(list(head(coll), at(coll, 1)), group2(from(coll, 2)))); };var reverse = function(coll){ return fold(coll, function(acc, cur){ return cons(cur, acc); }, []); };var comp = function(a, b){ return function(){ return a(app(b, toArray(arguments))); }; };var resplit = function(s, mat, val){ return join(split(s, mat), val); };var str = function(){ return join(toArray(arguments), ""); };var isArray = function(obj){ return (objStr(obj)==="[object Array]"); };var isString = function(obj){ return (objStr(obj)==="[object String]"); };var debug = function(str, val){ return (function(){log(str);return val;})(); };var callCons = function(f, args){ return list("trampoline-call", f, args); };var callT = function(f){ return callCons(f, tail(toArray(arguments))); };var valT = function(v){ return list("trampoline-val", v); };var isCall = function(trampoline){ return (head(trampoline)==="trampoline-call"); };var runT = function(f, start){ return (function(){var trampoline = callCons(f, start);while(isCall(trampoline)){trampoline = app(at(trampoline, 1), at(trampoline, 2));};return at(trampoline, 1);})(); };var parens = list("(", ")");var whitespace = list(" ", "\n");var skipSpace = function(stri){ return (empty(stri) ? stri : (has(whitespace, head(stri)) ? skipSpace(tail(stri)) : stri)); };var tokenRec = function(res, stri){ return (function(){var noSpaces = skipSpace(stri);return (empty(noSpaces) ? valT(res) : (function(){var hd = head(noSpaces);var tl = tail(noSpaces);return (has(parens, hd) ? callT(tokenRec, push(res, hd), tl) : ((hd==="\"") ? callT(nextOfString, "", false, res, tl) : ((hd===";") ? callT(nextOfComment, res, tl) : callT(nextOfVal, hd, res, tl))));})());})(); };var nextOfComment = function(res, stri){ return (empty(stri) ? valT(res) : (function(){var hd = head(stri);var tl = tail(stri);return ((hd==="\n") ? callT(tokenRec, res, tl) : callT(nextOfComment, res, tl));})()); };var nextOfVal = function(acc, res, stri){ return (empty(stri) ? valT(push(res, acc)) : (function(){var hd = head(stri);var tl = tail(stri);return (has(whitespace, hd) ? callT(tokenRec, push(res, acc), tl) : (has(parens, hd) ? callT(tokenRec, push(res, acc), stri) : callT(nextOfVal, str(acc, hd), res, tl)));})()); };var nextOfString = function(acc, escape, res, stri){ return (empty(stri) ? err("next of string expected more characters") : (function(){var hd = head(stri);var tl = tail(stri);return (((hd==="\\")&&!(escape)) ? callT(nextOfString, str(acc, hd), true, res, tl) : (((hd==="\"")&&!(escape)) ? callT(tokenRec, push(res, str("\"", acc, "\"")), tl) : callT(nextOfString, str(acc, hd), false, res, tl)));})()); };var tokenize = function(stri){ return runT(tokenRec, list([], stri)); };var INT_REGEX = str("^", "(-)?", "[0-9]+", "(", "(?:E|e)", "[0-9]+)?", "$");var STR_REGEX = str("^", "\"", ".*", "\"", "$");var quote = function(token){ return str("'", token); };var unquote = function(token){ return slice(token, 1); };var isQuoted = function(token){ return (head(token)==="'"); };var bools = list("true", "false");var tokenToVal = function(token){ return (matches(token, INT_REGEX) ? token : (matches(token, STR_REGEX) ? token : (has(bools, token) ? token : quote(token)))); };var parseRec = function(tree, tokens){ return (empty(tokens) ? tree : (function(){var hd = head(tokens);var tl = tail(tokens);return ((hd===")") ? err("error: did not expect closing parentheses") : ((hd==="(") ? parseStmt(1, push(tree, []), tl) : parseRec(push(tree, tokenToVal(hd)), tl)));})()); };var pushFromBottom = function(coll, item, place){ return ((place===0) ? push(coll, item) : push(init(coll), pushFromBottom(last(coll), item, (place-1)))); };var parseStmt = function(place, tree, tokens){ return (empty(tokens) ? err("error: expected more, unbalanced parentheses") : (function(){var hd = head(tokens);var tl = tail(tokens);return ((hd===")") ? ((place===1) ? parseRec(tree, tl) : parseStmt((place-1), tree, tl)) : ((hd==="(") ? parseStmt((place+1), pushFromBottom(tree, [], place), tl) : parseStmt(place, pushFromBottom(tree, tokenToVal(hd), place), tl)));})()); };var parse = function(tokens){ return parseRec([], tokens); };var replChars = function(name){ return resplit(resplit(resplit(name, "?", "Ques"), "!", "Excl"), "*", "Astsk"); };var sanitize = function(name){ return (function(){var replaced = replChars(name);var indexDash = indexOf(replaced, "-");return ((-1===indexDash) ? replaced : str(slice(replaced, 0, indexDash), upper(at(replaced, (indexDash+1))), sanitize(slice(replaced, (indexDash+2)))));})(); };var AstskatRootAstsk = newVar(false);var AstskexportsAstsk = newVar([]);var prettyQues = false;var newlineQues = (prettyQues ? "\n" : "");var macros = newObject();objSetExcl(macros, "!", function(tree){ return ((len(tree)===1) ? str("!(", compileExpr(head(tree)), ")") : err("! takes one arg")); });var infix = list("+", "-", "/", "*", "&&", "||", "<", ">", "<=", ">=");foreach(infix, function(infix){ return objSetExcl(macros, infix, function(tree){ return ((len(tree)===2) ? str("(", compileExpr(head(tree)), infix, compileExpr(at(tree, 1)), ")") : err(str(infix, " takes two args"))); }); });objSetExcl(macros, "==", function(tree){ return ((len(tree)===2) ? str("(", compileExpr(head(tree)), "===", compileExpr(at(tree, 1)), ")") : err("== takes two args")); });objSetExcl(macros, "!=", function(tree){ return ((len(tree)===2) ? str("(", compileExpr(head(tree)), "!==", compileExpr(at(tree, 1)), ")") : err("!= takes two args")); });objSetExcl(macros, "mod", function(tree){ return ((len(tree)===2) ? str("(", compileExpr(head(tree)), "%", compileExpr(at(tree, 1)), ")") : err("mod takes two args")); });objSetExcl(macros, "def", function(tree){ return ((len(tree)===2) ? (function(){var name = sanitize(unquote(head(tree)));(varGet(AstskatRootAstsk) ? varSwapExcl(AstskexportsAstsk, function(exports){ return push(exports, name); }) : []);return str("var ", name, " = ", compileExpr(at(tree, 1)));})() : err("def takes two args")); });objSetExcl(macros, "if", function(tree){ return ((len(tree)===3) ? str("(", compileExpr(head(tree)), " ? ", compileExpr(at(tree, 1)), " : ", compileExpr(at(tree, 2)), ")") : err("if takes three args")); });objSetExcl(macros, "do", function(tree){ return ((len(tree)===0) ? err("do takes at least one arg") : (function(){var _ = varSetExcl(AstskatRootAstsk, false);var mapper = comp(function(s){ return str(s, ";", newlineQues); }, compileExpr);var mapped = map(init(tree), mapper);var joined = join(mapped, "");return str("(function(){", newlineQues, joined, "return ", compileExpr(last(tree)), ";})()");})()); });objSetExcl(macros, "fn", function(tree){ return ((len(tree)===2) ? (function(){var unquoteThenSanitize = comp(sanitize, unquote);var hd = head(tree);var lenHd = len(hd);var hasSplat = ((lenHd>=2)&&(at(hd, (lenHd-2))===quote("&")));var splatName = (hasSplat ? unquoteThenSanitize(at(hd, (lenHd-1))) : "");var plainArgs = (hasSplat ? init(init(hd)) : hd);var argsList = map(plainArgs, unquoteThenSanitize);var joinedArgs = join(argsList, ", ");var splatHandling = (hasSplat ? str("var ", splatName, " = Array.prototype.slice.call(arguments,", len(argsList), ");", newlineQues) : "");var expr = compileExpr(at(tree, 1));return str("function(", joinedArgs, "){ ", splatHandling, "return ", expr, "; }");})() : err("fn takes two args")); });objSetExcl(macros, "defn", function(tree){ return ((len(tree)===3) ? (function(){var name = head(tree);var args = at(tree, 1);var body = at(tree, 2);var anon = list(quote("fn"), args, body);return compileExpr(list(quote("def"), name, anon));})() : err("defn takes three args")); });objSetExcl(macros, "let", function(tree){ return ((len(tree)===0) ? err("let takes at least one arg") : (function(){var expr = last(tree);var body = map(init(tree), function(tree){ return cons(quote("def"), tree); });var form = push(cons(quote("do"), body), expr);return compileExpr(form, body);})()); });objSetExcl(macros, "cond", function(tree){ return (((len(tree)%2)!==0) ? err("cond must take an even number of params") : ((len(tree)<=2) ? err("cond takes at least two args") : (function(){var lt = last(tree);var rest = slice(tree, 0, (len(tree)-2));var grouped = group2(rest);var form = foldR(grouped, function(acc, con){ return list(quote("if"), head(con), at(con, 1), acc); }, lt);return compileExpr(form);})())); });objSetExcl(macros, "while", function(tree){ return ((len(tree)>=2) ? (function(){var mapper = comp(function(s){ return str(s, ";", newlineQues); }, compileExpr);var mapped = map(tail(tree), mapper);var joined = join(mapped, "");return str("while(", compileExpr(head(tree)), "){", newlineQues, joined, "}");})() : err("while takes at least two args")); });objSetExcl(macros, "set!", function(tree){ return ((len(tree)===2) ? (function(){var name = sanitize(unquote(head(tree)));var body = compileExpr(at(tree, 1));return str(name, " = ", body);})() : err("set takes only two args")); });objSetExcl(macros, "js", function(tree){ return ((len(tree)===1) ? init(tail(head(tree))) : err("js takes only one arg")); });var compile = function(tree){ return (empty(tree) ? (function(){var exp = varGet(AstskexportsAstsk);var expList = join(exp, " ");var setters = [];var settersJoined = join(setters, "");return str(settersJoined, "// QUIDDITCH-EXPORTS ", expList, newlineQues);})() : (function(){varSetExcl(AstskatRootAstsk, true);return str(compileExpr(head(tree)), ";", newlineQues, compile(tail(tree)));})()); };var compileExpr = function(expr){ return (isArray(expr) ? (function(){var hd = head(expr);var tl = tail(expr);return (isString(hd) ? (function(){var unquoted = unquote(hd);return (hasKey(macros, unquoted) ? (objGet(macros, unquoted))(tl) : (function(){var mapped = map(tl, compileExpr);var joined = join(mapped, ", ");return str(sanitize(unquoted), "(", joined, ")");})());})() : (function(){var callee = compileExpr(hd);var mapped = map(tl, compileExpr);var joined = join(mapped, ", ");return str("(", callee, ")(", joined, ")");})());})() : (isQuoted(expr) ? ((expr===quote("nil")) ? "[]" : unquote(sanitize(expr))) : expr)); };var runCompiler = function(source){ return (function(){var tokens = tokenize(source);var parsed = parse(tokens);var compiled = compile(parsed);return compiled;})(); };var main = function(args){ return (function(){var util = require("util");var lenArgs = len(args);return ((lenArgs===2) ? (function(){var stdin = jsGet(process, "stdin");var stdout = jsGet(process, "stdout");var vm = require("vm");var sandbox = jsCall(vm, "createContext");log("Quidditch repl (ctrl-c to exit)");jsCall(stdout, "write", "> ");jsCall(stdin, "setEncoding", "utf8");return jsCall(stdin, "on", "readable", function(){ return (function(){var chunk = jsCall(stdin, "read");return ((chunk!==null) ? (function(){var compiled = runCompiler(chunk);var evaled = jsCall(vm, "runInContext", compiled, sandbox);var inspected = jsCall(util, "inspect", evaled, {depth:null});return jsCall(stdout, "write", str(inspected, "\n> "));})() : []);})(); });})() : (function(){var fs = require("fs");var file = jsCall(fs, "readFileSync", at(args, 2), "utf-8");var compiled = runCompiler(file);return log(compiled);})());})(); };main(argv);// QUIDDITCH-EXPORTS jsCall newObject objGet jsGet objSetExcl hasKey cons conc len indexOf replace head objStr matches slice split join foreach map reduce reduceR fold foldR upper lower toArray app log err argv newVar varSetExcl varGet varSwapExcl list empty init last push has at from tail irange range zip take group2 reverse comp resplit str isArray isString debug callCons callT valT isCall runT parens whitespace skipSpace tokenRec nextOfComment nextOfVal nextOfString tokenize INT_REGEX STR_REGEX quote unquote isQuoted bools tokenToVal parseRec pushFromBottom parseStmt parse replChars sanitize AstskatRootAstsk AstskexportsAstsk prettyQues newlineQues macros infix compile compileExpr runCompiler main
