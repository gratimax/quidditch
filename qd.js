var tryCall = function(f){ return (function(){var result;try { result = ['right', f()]; } catch (e) { result = ['left', e]; };return result;})(); };var jsCall = function(obj, f){ var args = Array.prototype.slice.call(arguments,2);return obj[f].apply(obj, args); };var newObject = function(){ return {}; };var objGet = function(obj, key){ return obj[key]; };var jsGet = objGet;var objSetExcl = function(obj, key, value){ return (function(){obj[key] = value;return obj;})(); };var hasKey = function(obj, key){ return (obj[key]&&jsCall(obj, "hasOwnProperty", key)); };var cons = function(a1, a2){ return jsCall([a1], "concat", a2); };var conc = function(a1, a2){ return jsCall(a1, "concat", a2); };var len = function(coll){ return jsGet(coll, "length"); };var indexOf = function(coll, i){ return jsCall(coll, "indexOf", i); };var replace = function(s, mat, val){ return jsCall(s, "replace", mat, val); };var head = function(l){ return l[0]; };var objStr = function(obj){ return Object.prototype.toString.call(obj); };var matches = function(stri, regex){ return jsCall(stri, "match", regex); };var slice = function(l, start, end){ return jsCall(l, "slice", start, end); };var split = function(s, splitter){ return jsCall(s, "split", splitter); };var join = function(coll, s){ return jsCall(coll, "join", s); };var foreach = function(coll, f){ return jsCall(coll, "forEach", f); };var map = function(coll, f){ return jsCall(coll, "map", f); };var filter = function(coll, f){ return jsCall(coll, "filter", f); };var reduce = function(coll, f){ return jsCall(coll, "reduce", f); };var reduceR = function(coll, f){ return jsCall(coll, "reduceRight", f); };var fold = function(coll, f, init){ return jsCall(coll, "reduce", f, init); };var foldR = function(coll, f, init){ return jsCall(coll, "reduceRight", f, init); };var upper = function(s){ return jsCall(s, "toUpperCase"); };var lower = function(s){ return jsCall(s, "toLowerCase"); };var app = function(f, args){ return jsCall(f, "apply", null, args); };var log = function(msg){ return (function(){jsCall(console, "log", msg);return msg;})(); };var err = function(msg){ return (function(){jsCall(console, "error", msg);return msg;})(); };var argv = jsGet(process, "argv");var list = function(){ var args = Array.prototype.slice.call(arguments,0);return args; };var empty = function(l){ return (len(l)===0); };var init = function(l){ return slice(l, 0, (len(l)-1)); };var last = function(l){ return at(l, (len(l)-1)); };var push = function(l, elem){ return conc(l, list(elem)); };var has = function(l, item){ return (empty(l) ? false : ((head(l)===item) ? true : has(tail(l), item))); };var at = function(l, i){ return l[i]; };var from = function(l, start){ return slice(l, start, len(l)); };var tail = function(l){ return from(l, 1); };var irange = function(end){ return ((end===0) ? list(0) : push(irange((end-1)), end)); };var range = function(end){ return init(irange(end)); };var zip = function(coll1, coll2){ return ((len(coll1)===len(coll2)) ? map(range(len(coll1)), function(i){ return list(at(coll1, i), at(coll2, i)); }) : err("collections must be same size")); };var take = function(i, coll){ return ((i===0) ? [] : push(take((i-1), coll), at(coll, i))); };var group2 = function(coll){ return (empty(coll) ? [] : cons(list(head(coll), at(coll, 1)), group2(from(coll, 2)))); };var reverse = function(coll){ return fold(coll, function(acc, cur){ return cons(cur, acc); }, []); };var comp = function(a, b){ return function(){ var args = Array.prototype.slice.call(arguments,0);return a(app(b, args)); }; };var resplit = function(s, mat, val){ return join(split(s, mat), val); };var str = function(){ var args = Array.prototype.slice.call(arguments,0);return join(args, ""); };var isArray = function(obj){ return (objStr(obj)==="[object Array]"); };var isString = function(obj){ return (objStr(obj)==="[object String]"); };var debug = function(str, val){ return (function(){log(str);return val;})(); };var callCons = function(f, args){ return list("trampoline-call", f, args); };var callT = function(f){ var args = Array.prototype.slice.call(arguments,1);return callCons(f, args); };var valT = function(v){ return list("trampoline-val", v); };var isCall = function(trampoline){ return (head(trampoline)==="trampoline-call"); };var runT = function(f, start){ return (function(){var trampoline = callCons(f, start);while(isCall(trampoline)){trampoline = app(at(trampoline, 1), at(trampoline, 2));};return at(trampoline, 1);})(); };var left = function(val){ return list("left", val); };var right = function(val){ return list("right", val); };var isLeft = function(either){ return (head(either)==="left"); };var isRight = function(either){ return (head(either)==="right"); };var eitherGet = function(either){ return head(tail(either)); };var parens = list("(", ")");var whitespace = list(" ", "\n");var skipSpace = function(stri){ return (empty(stri) ? stri : (has(whitespace, head(stri)) ? skipSpace(tail(stri)) : stri)); };var tokenRec = function(res, stri){ return (function(){var noSpaces = skipSpace(stri);return (empty(noSpaces) ? valT(res) : (function(){var hd = head(noSpaces);var tl = tail(noSpaces);return (has(parens, hd) ? callT(tokenRec, push(res, hd), tl) : ((hd==="\"") ? callT(nextOfString, "", false, res, tl) : ((hd===";") ? callT(nextOfComment, res, tl) : callT(nextOfVal, hd, res, tl))));})());})(); };var nextOfComment = function(res, stri){ return (empty(stri) ? valT(res) : (function(){var hd = head(stri);var tl = tail(stri);return ((hd==="\n") ? callT(tokenRec, res, tl) : callT(nextOfComment, res, tl));})()); };var nextOfVal = function(acc, res, stri){ return (empty(stri) ? valT(push(res, acc)) : (function(){var hd = head(stri);var tl = tail(stri);return (has(whitespace, hd) ? callT(tokenRec, push(res, acc), tl) : (has(parens, hd) ? callT(tokenRec, push(res, acc), stri) : callT(nextOfVal, str(acc, hd), res, tl)));})()); };var nextOfString = function(acc, escape, res, stri){ return (empty(stri) ? err("next of string expected more characters") : (function(){var hd = head(stri);var tl = tail(stri);return (((hd==="\\")&&!(escape)) ? callT(nextOfString, str(acc, hd), true, res, tl) : (((hd==="\"")&&!(escape)) ? callT(tokenRec, push(res, str("\"", acc, "\"")), tl) : callT(nextOfString, str(acc, hd), false, res, tl)));})()); };var tokenize = function(stri){ return runT(tokenRec, list([], stri)); };var INT_REGEX = str("^", "(-)?", "[0-9]+", "(", "(?:E|e)", "[0-9]+)?", "$");var STR_REGEX = str("^", "\"", ".*", "\"", "$");var quote = function(token){ return str("'", token); };var unquote = function(token){ return slice(token, 1); };var isQuoted = function(token){ return (head(token)==="'"); };var bools = list("true", "false");var tokenToVal = function(token){ return (matches(token, INT_REGEX) ? token : (matches(token, STR_REGEX) ? token : (has(bools, token) ? token : quote(token)))); };var parseRec = function(tree, tokens){ return (empty(tokens) ? tree : (function(){var hd = head(tokens);var tl = tail(tokens);return ((hd===")") ? err("error: did not expect closing parentheses") : ((hd==="(") ? parseStmt(1, push(tree, []), tl) : parseRec(push(tree, tokenToVal(hd)), tl)));})()); };var pushFromBottom = function(coll, item, place){ return ((place===0) ? push(coll, item) : push(init(coll), pushFromBottom(last(coll), item, (place-1)))); };var parseStmt = function(place, tree, tokens){ return (empty(tokens) ? err("error: expected more, unbalanced parentheses") : (function(){var hd = head(tokens);var tl = tail(tokens);return ((hd===")") ? ((place===1) ? parseRec(tree, tl) : parseStmt((place-1), tree, tl)) : ((hd==="(") ? parseStmt((place+1), pushFromBottom(tree, [], place), tl) : parseStmt(place, pushFromBottom(tree, tokenToVal(hd), place), tl)));})()); };var parse = function(tokens){ return parseRec([], tokens); };var replChars = function(name){ return resplit(resplit(resplit(name, "?", "Ques"), "!", "Excl"), "*", "Astsk"); };var sanitize = function(name){ return (function(){var replaced = replChars(name);var indexDash = indexOf(replaced, "-");return ((-1===indexDash) ? replaced : str(slice(replaced, 0, indexDash), upper(at(replaced, (indexDash+1))), sanitize(slice(replaced, (indexDash+2)))));})(); };var prettyQues = false;var newlineQues = (prettyQues ? "\n" : "");var macros = newObject();var builtins = newObject();objSetExcl(builtins, "!", function(tree){ return ((len(tree)===1) ? str("!(", codegen(head(tree)), ")") : err("! takes one arg")); });var infix = list("+", "-", "/", "*", "&&", "||", "<", ">", "<=", ">=");foreach(infix, function(infix){ return objSetExcl(builtins, infix, function(tree){ return ((len(tree)===2) ? str("(", codegen(head(tree)), infix, codegen(at(tree, 1)), ")") : err(str(infix, " takes two args"))); }); });objSetExcl(builtins, "==", function(tree){ return ((len(tree)===2) ? str("(", codegen(head(tree)), "===", codegen(at(tree, 1)), ")") : err("== takes two args")); });objSetExcl(builtins, "!=", function(tree){ return ((len(tree)===2) ? str("(", codegen(head(tree)), "!==", codegen(at(tree, 1)), ")") : err("!= takes two args")); });objSetExcl(builtins, "mod", function(tree){ return ((len(tree)===2) ? str("(", codegen(head(tree)), "%", codegen(at(tree, 1)), ")") : err("mod takes two args")); });objSetExcl(builtins, "def", function(tree){ return ((len(tree)===2) ? (function(){var name = sanitize(unquote(head(tree)));return str("var ", name, " = ", codegen(at(tree, 1)));})() : err("def takes two args")); });objSetExcl(builtins, "if", function(tree){ return ((len(tree)===3) ? str("(", codegen(head(tree)), " ? ", codegen(at(tree, 1)), " : ", codegen(at(tree, 2)), ")") : err("if takes three args")); });objSetExcl(builtins, "do", function(tree){ return ((len(tree)===0) ? err("do takes at least one arg") : (function(){var mapper = comp(function(s){ return str(s, ";", newlineQues); }, codegen);var mapped = map(init(tree), mapper);var joined = join(mapped, "");return str("(function(){", newlineQues, joined, "return ", codegen(last(tree)), ";})()");})()); });objSetExcl(builtins, "fn", function(tree){ return ((len(tree)===2) ? (function(){var unquoteThenSanitize = comp(sanitize, unquote);var hd = head(tree);var lenHd = len(hd);var hasSplat = ((lenHd>=2)&&(last(init(hd))===quote("&")));var splatName = (hasSplat ? unquoteThenSanitize(last(hd)) : "");var plainArgs = (hasSplat ? init(init(hd)) : hd);var argsList = map(plainArgs, unquoteThenSanitize);var joinedArgs = join(argsList, ", ");var splatHandling = (hasSplat ? str("var ", splatName, " = Array.prototype.slice.call(arguments,", len(argsList), ");", newlineQues) : "");var expr = codegen(at(tree, 1));return str("function(", joinedArgs, "){ ", splatHandling, "return ", expr, "; }");})() : err("fn takes two args")); });objSetExcl(builtins, "while", function(tree){ return ((len(tree)>=2) ? (function(){var mapper = comp(function(s){ return str(s, ";", newlineQues); }, codegen);var mapped = map(tail(tree), mapper);var joined = join(mapped, "");return str("while(", codegen(head(tree)), "){", newlineQues, joined, "}");})() : err("while takes at least two args")); });objSetExcl(builtins, "set!", function(tree){ return ((len(tree)===2) ? (function(){var name = sanitize(unquote(head(tree)));var body = codegen(at(tree, 1));return str(name, " = ", body);})() : err("set takes only two args")); });objSetExcl(builtins, "js", function(tree){ return ((len(tree)===1) ? init(tail(head(tree))) : err("js takes only one arg")); });objSetExcl(macros, "defn", function(tree){ return ((len(tree)===3) ? (function(){var name = head(tree);var args = at(tree, 1);var body = at(tree, 2);var anon = list(quote("fn"), args, body);return list(quote("def"), name, anon);})() : err("defn takes three args")); });objSetExcl(macros, "let", function(tree){ return ((len(tree)===0) ? err("let takes at least one arg") : (function(){var expr = last(tree);var body = map(init(tree), function(tree){ return cons(quote("def"), tree); });var form = push(cons(quote("do"), body), expr);return form;})()); });objSetExcl(macros, "cond", function(tree){ return (((len(tree)%2)!==0) ? err("cond must take an even number of params") : ((len(tree)<=2) ? err("cond takes at least two args") : (function(){var lt = last(tree);var rest = slice(tree, 0, (len(tree)-2));var grouped = group2(rest);var form = foldR(grouped, function(acc, con){ return list(quote("if"), head(con), at(con, 1), acc); }, lt);return form;})())); });var codegen = function(expr){ return (isArray(expr) ? (function(){var hd = head(expr);var tl = tail(expr);return (isString(hd) ? (function(){var unquoted = unquote(hd);return (hasKey(builtins, unquoted) ? (objGet(builtins, unquoted))(tl) : (function(){var mapped = map(tl, codegen);var joined = join(mapped, ", ");return str(sanitize(unquoted), "(", joined, ")");})());})() : (function(){var callee = codegen(hd);var mapped = map(tl, codegen);var joined = join(mapped, ", ");return str("(", callee, ")(", joined, ")");})());})() : (isQuoted(expr) ? ((expr===quote("nil")) ? "[]" : sanitize(unquote(expr))) : expr)); };var macroExpand = function(expr){ return (isArray(expr) ? (function(){var hd = head(expr);var tl = tail(expr);return (isString(hd) ? (function(){var unquoted = unquote(hd);return (hasKey(macros, unquoted) ? map((objGet(macros, unquoted))(tl), macroExpand) : cons(hd, map(tl, macroExpand)));})() : map(expr, macroExpand));})() : expr); };var isDef = function(expr){ return (head(expr)===quote("def")); };var getDef = function(expr){ return sanitize(unquote(at(expr, 1))); };var getDefs = function(exprs){ return (function(){var onlyDefs = filter(exprs, isDef);return map(onlyDefs, getDef);})(); };var hasNs = function(exprs){ return (head(head(exprs))===quote("ns")); };var getDependencies = function(exprs){ return (hasNs(exprs) ? map(tail(tail(head(exprs))), function(bindings){ return join(map(bindings, comp(sanitize, unquote)), " "); }) : []); };var endExpr = function(expr){ return str(expr, ";", newlineQues); };var compile = function(source, compileNs){ return (function(){var tokens = tokenize(source);var parsed = parse(tokens);var expanded = map(parsed, macroExpand);var defs = getDefs(expanded);var dependencies = getDependencies(expanded);var generated = app(str, map((compileNs ? tail(expanded) : expanded), comp(endExpr, codegen)));return str(generated, "\n// QUIDDITCH-EXPORTS ", join(defs, " "), "\n// QUIDDITCH-DEPENDENCIES ", join(dependencies, " "));})(); };var fs = [];var compileFile = function(file){ return (function(){var source = jsCall(fs, "readFileSync", file, "utf-8");return compile(source, true);})(); };var main = function(args){ return (function(){var util = require("util");var _ = fs = require("fs");var lenArgs = len(args);return ((lenArgs===2) ? (function(){var stdin = jsGet(process, "stdin");var stdout = jsGet(process, "stdout");var vm = require("vm");var sandbox = jsCall(vm, "createContext");var stdlibCompiled = compileFile("stdlib.lisp");jsCall(vm, "runInContext", stdlibCompiled, sandbox);log("Quidditch repl (ctrl-c to exit)");jsCall(stdout, "write", "> ");jsCall(stdin, "setEncoding", "utf8");return jsCall(stdin, "on", "readable", function(){ return (function(){var chunk = jsCall(stdin, "read");return ((chunk!==null) ? (function(){var compiled = compile(chunk, false);var evaled = tryCall(function(){ return jsCall(vm, "runInContext", compiled, sandbox); });return (isRight(evaled) ? (function(){var inspected = jsCall(util, "inspect", eitherGet(evaled), {depth:null});return jsCall(stdout, "write", str(inspected, "\n> "));})() : jsCall(stdout, "write", str(eitherGet(evaled), "\n> ")));})() : []);})(); });})() : (function(){var file = at(args, 2);var compiled = compileFile(file);return log(compiled);})());})(); };main(argv);
// QUIDDITCH-EXPORTS tryCall jsCall newObject objGet jsGet objSetExcl hasKey cons conc len indexOf replace head objStr matches slice split join foreach map filter reduce reduceR fold foldR upper lower app log err argv list empty init last push has at from tail irange range zip take group2 reverse comp resplit str isArray isString debug callCons callT valT isCall runT left right isLeft isRight eitherGet parens whitespace skipSpace tokenRec nextOfComment nextOfVal nextOfString tokenize INT_REGEX STR_REGEX quote unquote isQuoted bools tokenToVal parseRec pushFromBottom parseStmt parse replChars sanitize prettyQues newlineQues macros builtins infix codegen macroExpand isDef getDef getDefs hasNs getDependencies endExpr compile fs compileFile main
// QUIDDITCH-DEPENDENCIES
