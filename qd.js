var object = function(){ return {}; };
var get = function(obj, key){ return obj[key]; };
var set = function(obj, key, value){ return (function(){obj[key]=value;
return obj; })(); };
var cons = function(a1, a2){ return [a1].concat(a2); };
var conc = function(a1, a2){ return a1.concat(a2); };
var len = function(coll){ return coll.length; };
var head = function(l){ return l[0]; };
var slice = function(l, start, end){ return l.slice(start, end); };
var strHead = function(s){ return s.charAt(0); };
var strTail = function(s){ return s.substring(1); };
var split = function(s, splitter){ return s.split(splitter); };
var join = function(coll, s){ return coll.join(s); };
var toArray = function(coll){ return Array.prototype.slice.call(coll); };
var log = function(msg){ return console.log(msg); };
var err = function(msg){ return console.error(msg); };
var argv = process.argv;
var list = function(){ return toArray(arguments); };
var empty = function(l){ return (len(l)===0); };
var init = function(l){ return slice(l, 0, (len(l)-1)); };
var last = function(l){ return at(l, (len(l)-1)); };
var has = function(l, item){ return (empty(l) ? false : ((head(l)===item) ? true : has(tail(l), item))); };
var at = function(l, i){ return (empty(l) ? err("cannot at from empty list") : ((i===0) ? head(l) : at(tail(l), (i-1)))); };
var from = function(l, start){ return slice(l, start, len(l)); };
var tail = function(l){ return from(l, 1); };
var app = function(arg, l){ return l(arg); };
var str = function(){ return join(toArray(arguments), ""); };
var parens = list("(", ")");
var whitespace = list(" ", "\n");
var infix = list("==", "+", "-", "/", "*", "&&", "||");
var skipSpace = function(stri){ return (empty(stri) ? stri : (has(whitespace, strHead(stri)) ? skipSpace(strTail(stri)) : stri)); };
var nextOfString;
var nextOfVal;
var tokenRec = function(res, stri){ return (empty(stri) ? res : (function(){var noSpaces = skipSpace(stri);
var hd = strHead(noSpaces);
var tl = strTail(noSpaces);
return (has(parens, hd) ? tokenRec(conc(res, list(hd)), tl) : ((hd==="\"") ? nextOfString("", false, res, tl) : ((hd===";") ? nextOfComment(res, tl) : nextOfVal(hd, res, tl)))); })()); };
var nextOfComment = function(res, stri){ return (empty(stri) ? res : (function(){var hd = strHead(stri);
var tl = strTail(stri);
return ((hd==='\n') ? tokenRec(res, tl) : nextOfComment(res, tl)); })()); };
var nextOfVal = function(acc, res, stri){ return (empty(stri) ? conc(res, list(acc)) : (function(){var hd = strHead(stri);
var tl = strTail(stri);
return (has(whitespace, hd) ? tokenRec(conc(res, list(acc)), tl) : (has(parens, hd) ? tokenRec(conc(res, list(acc)), stri) : nextOfVal(str(acc, hd), res, tl))); })()); };
var nextOfString = function(acc, escape, res, stri){ return (empty(stri) ? err("next of string expected more characters") : (function(){var hd = strHead(stri);
var tl = strTail(stri);
return (((hd==="\\")&&!(escape)) ? nextOfString((acc+hd), true, res, tl) : (((hd==="\"")&&!(escape)) ? tokenRec(conc(res, list(str("\"", acc, "\""))), tl) : nextOfString(str(acc, hd), false, res, tl))); })()); };
var tokenize = function(stri){ return tokenRec([], stri); };
var ncompile = function(tokens, stri){ return list(tokens, stri); };
var gtokens = function(struct){ return head(struct); };
var gstr = function(struct){ return at(struct, 1); };
var nargs = function(tokens, args){ return list(tokens, args); };
var gargs = function(struct){ return at(struct, 1); };
var compileArgs;
var compileAnonArgs;
var compileDo;
var compileExpr = function(tokens){ return (empty(tokens) ? err("error: unexpected end") : (function(){var hd = head(tokens);
var tl = tail(tokens);
return ((hd===")") ? err("error: unexpected closing paren expr") : ((hd==="(") ? compileApp(tl) : ((hd==="nil") ? ncompile(tl, "[]") : ncompile(tl, hd)))); })()); };
var compileApp = function(tokens){ return (empty(tokens) ? err("error: unexpected end") : (function(){var hd = head(tokens);
var tl = tail(tokens);
return ((hd===")") ? err("error: unexpected closing paren app") : ((hd==="(") ? (function(){var step = compileExpr(tokens);
var args = compileArgs(gtokens(step));
var joined = join(gargs(args), ", ");
return ncompile(gtokens(args), str("(", joined, ")")); })() : ((hd==="def") ? (function(){var args = compileArgs(tl);
var argslist = gargs(args);
return ((1===len(argslist)) ? ncompile(gtokens(args), str("var ", head(argslist))) : ((2===len(argslist)) ? ncompile(gtokens(args), str("var ", head(argslist), " = ", at(argslist, 1))) : err("error: def expects one or two args"))); })() : (has(infix, hd) ? (function(){var arg1 = compileExpr(tl);
var arg2 = compileExpr(gtokens(arg1));
var infix = ((hd==="==") ? "===" : hd);
return ncompile(tail(gtokens(arg2)), str("(", gstr(arg1), infix, gstr(arg2), ")")); })() : ((hd==="!") ? (function(){var expr = compileExpr(tl);
return ncompile(tail(gtokens(expr)), str("!(", gstr(expr), ")")); })() : ((hd==="fn") ? (function(){var args = compileAnonArgs(tail(tl));
var expr = compileExpr(gtokens(args));
var joined = join(gargs(args), ", ");
return ncompile(tail(gtokens(expr)), str("function(", joined, "){ return ", gstr(expr), "; }")); })() : ((hd==="if") ? (function(){var condition = compileExpr(tl);
var expr1 = compileExpr(gtokens(condition));
var expr2 = compileExpr(gtokens(expr1));
return ncompile(tail(gtokens(expr2)), str("(", gstr(condition), " ? ", gstr(expr1), " : ", gstr(expr2), ")")); })() : ((hd==="do") ? (function(){var expr = compileDo([], tl);
var args = gargs(expr);
var stmts = init(args);
var ret = last(args);
var joined = join(stmts, ";\n");
return ncompile(gtokens(expr), str("(function(){", joined, ";\nreturn ", ret, "; })()")); })() : (function(){var args = compileArgs(tl);
var joined = join(gargs(args), ", ");
return ncompile(gtokens(args), str(hd, "(", joined, ")")); })())))))))); })()); };
var compileArgs = function(tokens){ return (empty(tokens) ? err("error: unexpected end") : (function(){var hd = head(tokens);
return ((hd===")") ? nargs(tail(tokens), []) : (function(){var expr = compileExpr(tokens);
var rest = compileArgs(gtokens(expr));
return nargs(gtokens(rest), cons(gstr(expr), gargs(rest))); })()); })()); };
var compileAnonArgs = function(tokens){ return (empty(tokens) ? err("error: unexpected end") : (function(){var hd = head(tokens);
var tl = tail(tokens);
return ((hd===")") ? nargs(tl, []) : (function(){var rest = compileAnonArgs(tl);
return nargs(gtokens(rest), cons(hd, gargs(rest))); })()); })()); };
var compileDo = function(stmts, tokens){ return (empty(tokens) ? err("error: unexpected end") : (function(){var hd = head(tokens);
var tl = tail(tokens);
return ((hd===")") ? nargs(tl, stmts) : (function(){var next = compileExpr(tokens);
return compileDo(conc(stmts, list(gstr(next))), gtokens(next)); })()); })()); };
var compile = function(tokens){ return (empty(tokens) ? "" : (function(){var step = compileExpr(tokens);
return str(gstr(step), ";\n", compile(gtokens(step))); })()); };
var main = function(args){ return (function(){var fs = require("fs");
var tokens = tokenize(fs.readFileSync(at(args, 2), "utf-8"));
var compiled = compile(tokens);
return log(compiled); })(); };
main(argv);

